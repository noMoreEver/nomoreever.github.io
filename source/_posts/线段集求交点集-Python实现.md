---
title: 线段集求交点集-Python实现
date: 2025-05-04 15:38:56
tags: ['图形算法']
category: '图形算法'
---
# 平面扫描算法求解n个二维直线求交点集--Python实现
> 代码地址https://github.com/noMoreEver/computational-geometry
> 参考：
> 1.《计算几何-算法与应用》第二章第一节
> 2. 平面扫描法大佬C++实现https://github.com/johnhany/SegmentsIntersection

**后记** -- 难怪网上关于这个算法的介绍也不多：
1. 非常见数据结构。使用<u>特殊二叉树</u>结构存储数据，只有页节点存数据，中间节点（图中圆形）不存数据。如下图
   ![](1746273183.png)
2. 需要对所有线段排序
3. 算法上下文关联，难以分解成多个任务<u>多线程运行</u>。

**我的实现方案**：
实现暴力方法求解，记录所需时间。平面扫描法则可见https://github.com/johnhany/SegmentsIntersection
![](1746343766.png)

| 线段数量 | 所需时间 |
| - | - |
|    10    | 0.0008327960968017578 |
|    50    |  0.017670392990112305 |
|   100    |  0.06802940368652344  |
|   500    |   1.6727917194366455  |
|   1000   |   6.655669689178467   |


## 问题定义
给定由平面上n条闭线段成的一个集合S，计算出 S 中线段之间的所有交点。
![](1746102980.png)

很明显可以暴力求解，一一选取每一条线段求交点，该方法需要O(n * n)时间，该方法适用于：
1. 大部分线段都相交的情况
2. 线段数量较少

但在实际使用中，大多数线段<u>都不和其他线段相交，或只与少数线段相交</u>，此时交点数达不到平方量级。
因此科学家Bentley和Ottmann在1979年构造了一种不仅取决于线段数量，还取决于交点数目的**输出敏感算法** -- 平面扫描法。
该方法时间复杂度为O(nlogn+klogn)，k为交点个数，在n较大，k较少时具有较好的效率。

## 平面扫描法
几何特性：那些相互靠近的线段，才能会相交；而相距甚远的线段则不可能相交。
使用一条水平线从上至下移动。
1. 上端点
   遇到线段上端点就加入`集合`，对于加入的所有线段<u>上端点水平位置排序</u>。
   同时求该端点与相邻两端点的交点位置，若有交点则将交点加入。
2. 下端点
   遇到下端点则移除改点，同时对其左邻居和右邻居求交点，若存在则将交点加入
3. 交点
   输出交点，将左线段的左邻居与右线段求交，右线段的右邻居与左线段求交，若存在则将交点加入。

```
算法 HANDLEEVENTPOINT(p)
1. 令 U(p)为所有以 p 为上端点的线段构成的集合；
这些线段都与事件点 p 存放在一起
（若是水平线段，则以其左端点做为上端点）
2. 在T中找出包含p的所有线段 ①
 (* 在T中，这些线段是（依次）相邻的 *)
在所找出的线段中
 将那些以p为下端点的线段组成集合L(p)
 将那些在内部包含p的线段组成集合C(p)
3. if (L(p)∪U(p)∪C(p)包含不止一条线段)
4. then 报告“发现交点 p”；同时返回 L(p)、U(p)和 C(p)
5. 将 L(p)∪C(p)中的线段从 T 中删除
6. 将U(p)∪C(p)中的线段插入到T中
 (* T中各线段的次序，必须与它们和扫描线刚离开p之后的相交次序一致 *)
 (* 若存在水平的线段，则将它排在包含p的所有线段 ②的最后 *)
7. (* 将 C(p)中的线段删除，然后按照逆序重新插入 *)
8. if (U(p)∪C(P) = ∅)
9. then 在 T 中，找出 p 的左右邻居 sl 和 sr
10. FindNewEvent(sl, sr, p)
11. else 在 T 中，找出 U(p)∪C(p)里最左边的线段 s'
12. 在 T 中，找出与 s'紧邻于左侧的线段 sl
13. FindNewEvent(sl, s', p)
14. 在 T 中，找出 U(p)∪C(p)里最右边的线段 s''
15. 在 T 中，找出与 s''紧邻于右侧的线段 sr
16. FindNewEvent(s'', sr, p) 
```